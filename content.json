{"meta":{"title":"My Blog","subtitle":null,"description":null,"author":"lowkey","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"test","slug":"test","date":"2017-02-06T04:29:24.000Z","updated":"2017-02-06T04:34:46.068Z","comments":true,"path":"2017/02/06/test/","link":"","permalink":"http://yoursite.com/2017/02/06/test/","excerpt":"","text":"what is goddess? 女神大概就是那種，見不到面就時刻在想念著，有一肚子的話想要告訴她，但是見了面又不知道說什麽了，想把自己的一切都給她的那種人吧。","categories":[],"tags":[]},{"title":"Hello My Goddess","slug":"hello-world","date":"2017-02-06T04:14:03.709Z","updated":"2017-02-06T04:26:47.434Z","comments":true,"path":"2017/02/06/hello-world/","link":"","permalink":"http://yoursite.com/2017/02/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"版本控制工具","slug":"包管理工具svn和git","date":"2016-09-07T12:45:42.000Z","updated":"2017-03-01T12:59:08.155Z","comments":true,"path":"2016/09/07/包管理工具svn和git/","link":"","permalink":"http://yoursite.com/2016/09/07/包管理工具svn和git/","excerpt":"","text":"版本控制问题1：历史记录问题2：多人协作解决问题：软件12345版本 用户 说明 日期1 张三 删除了软件服务条款5 7/12 10:382 张三 增加了License人数限制 7/12 18:093 李四 财务部门调整了合同金额 7/13 9:514 张三 延长了免费升级周期 7/14 15:17 什么是版本控制？版本管理就是管理更新的历史记录，它给我们提供了一些在软件开发过程中必不可少的功能，例如： 记录一款软件添加或更改源代码的过程 回滚到特定阶段，恢复误删除的文件 合并多人协作的文件等 多人协同，文件传输 版本控制分类 集中式 SVN 分布式 Git SVNSVN 全称 Apache Subversion，是一个开放源代码的集中式版本管理系统。在 2000 年由 CollabNet 开发，现已发展成为 Apache 软件基金会的一个开源项目。 环境安装SVN 交互协作流程 集中式早期的版本管理就是以 Apache Subversion 为代表的集中式版本管理，集中式版本管理将所有的数据集中存放在服务器中，这是有便于统一管理的优点。但是一旦开发者所处的环境不能连接服务器，就无法获取最新源代码，开发也就无法进行。服务器宕机时也是同样的道理，而且万一服务器故障导致数据丢失，恐怕开发者就再也见不到最新的源代码了。 简而言之： 中央服务器好比是一个图书馆 你要改一本书，必须先从图书馆借出来（checkout） 然后回到家自己改，改完了，再放到图书馆（commit） 一些术语 源代码库（repository）：源代码统一存放的地方 检出（checkout）：当你手上没有源代码的时候，就需要从 responsive checkout 一份 提交（commit）：当你已经修改了代码，就需要 commit 到 repository 更新（update）：当你已经 checkout 了一份源代码，Update 一下就可以和 repository 上的源代码同步，你手上的代码就会有最新的变更 使用 VisualSVN 搭建 SVN 服务器SVN 服务器：运行 Subversion 服务的计算机。 为了方便，我们这里使用比较流行的图形化工具 VisualSVN来搭建我们的 SVN 服务。 安装完毕之后，基本使用流程如下： 创建用户 创建版本仓库 设定用户权限 使用 TortoiseSVN 作为 SVN 客户端SVN 客户端：用户通过SVN客户端同SVN服务器交互 这里我们使用最流行的 TortoiseSVN https://DESKTOP-40UMEJI:8443/svn/jd https://192.168.133.25:8443/svn/jd TortoiseSVN 客户端基本操作流程 检出项目：checkout 在没有源代码的前提下，需要通过 tortoise-svn 客户端下载 提交修改：commit 帮你记录当前开发的软件的状态 更新文件或目录：update（更新） 别的开发人员在已有源代码的前提下可以通过 update 更新服务器上最新的版本 查看版本日志：log（日志） 关于冲突假设 A、B 两个用户都在版本号为 100 的时候，更新了 kingtuns.txt 这个文件，A 用户在修改完成之后提交 kingtuns.txt 到服务器， 这个时候提交成功，这个时候 kingtuns.txt 文件的版本号已经变成 101 了。同时B用户在版本号为 100 的 kingtuns.txt 文件上作修改， 修改完成之后提交到服务器时，由于不是在当前最新的 101 版本上作的修改，所以导致提交失败。 良好的使用习惯就是，提交之前，先更新。 为了避免冲突，别人的文件你最好不要动，万一你要修改公共的文件或者是别人的文件，跟别人最好口头沟通好，就是你改动的时候，别人最好不要去改动，这样才能最大程度上避免冲突的问题。 多人协作时，同个目录或同个文件需要不同成员共同开发，这个时候 commit 和 update 就可能出现冲突。 两个程序员只要不是修改了同一行程序，SVN 可以通过 update 自动合并修改 但是如果两个程序员修改了同一行程序， SVN 会提示文件 conflict，需要手动确定 如何解决？ 第一种解决方法：手动合并冲突的内容 第二种解决方法：每次修改某个文件的时候对文件上锁，这样你在修改的过程中别人就无法更新这个文件 建议： 一个文件最好同一时间只被一个人修改提交 多跟团队成员沟通 不要随便去修改别人的文件 版本管理使用建议 不要频繁的提交版本 一般有比较成熟的功能模块的时候，再去提交 修复了功能性 bug 的时候再去提交 提交的代码最好无 bug 每次 commit 之前都要 update 因为你在编辑这个文件的时候，可能比人已经编辑并提交了某个版本 所以先 update，目的是为了检查一下服务器上有没有最新版，如果有，直接更新 更新的过程中如果遇到冲突，不要慌，去手动解决 每次 commit 的时候都务必要写提交日志 这个提交日志就好比你保存副本的时候加的一个标记 目的是为了日后做版本的回退查找以及查看记录更新状态 使用总结 版本控制管理系统 源代码仓库 repository 检出代码 checkout 更新最新源代码 update 提交修改 commit 其它 清除svn保存的username用户名和paasword密码(windows和linux) 菜鸟教程 - SVN 教程 Git 维基百科 - Git 学习资源介绍 Git教程 - 廖雪峰 Pro Git git - 简明指南 猴子都能懂的GIT入门 Git 简介 是什么 Git 也是一个版本控制管理软件 有什么用，可以解决什么问题 保存历史记录 多人协作 有了 SVN，为啥要学 Git Git 火 Git 相对于 SVN 来说，更强大，用户也非常多 怎么用 Git 的诞生 http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000 Git 使用交互流程 安装和配置 Git 环境 下载地址：https://git-scm.com/ git-bash 常用命令 pwd ls ls -a cd mkdir clear rmdir 只能删除空目录 rm rm 文件名 rm -rf 目录名 注：很强大，可以删除非空目录，以及一些比较顽固的文件或者目录 初始化配置12345678# 设置用户名git config --global user.name \"你的名字\"# 配置用户邮箱git config --global user.email \"你的常用邮箱\"# 设置 gitk 图形查看工具中文显示默认编码（防止乱码）git config --global gui.encoding utf-8# 查看配置列表项git config --list 基本使用 git init 初始化一个 Git 仓库 git status 查看当前工作区、暂存区、本地仓库的状态 git add git commit 示例：git commit -m &quot;日志说明&quot; --author=&quot;操作者姓名 &lt;邮箱&gt;&quot; 执行 git commit 的时候，Git 会要求具有用户名和邮箱的参数选项 可以通过 git config 命令配置一下用户名和邮箱 git log gitk 总结：操作 Git 的基本工作流程就是先修改文件，然后执行 git add 命令。git add 命令会把文件加入到暂存区，接着就可以执行 git commit 命令，将文件存入文档库，从而形成一次历史记录。 问题1：关于 Git-bash 中文问题 Git for Windows Unicode Support 问题2：执行 commit 的时候一大堆的信息 问题3：配置 user.name 和 user.email 问题 工作区、暂存区、本地仓库版本回退1234567891011121314151617181920212223242526272829303132$ git rm --cached &lt;file&gt;# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 远程同步 remote push pull 在线仓库托管服务 一个不知道 github、stackoverflow 的程序员想想都是可悲的 github 码云 coding Github Github 就是程序员的新浪微博它可以让你使用社交化的方式进行编程协作、 - 点赞 - 评论 - 转发 - etc. 主要作用：可以免费在线托管你的仓库可以实现多人协作提供了一个可视化界面（Web Page）让你能直观清晰的了解你的项目源代码 基本使用 注册 登陆 创建远程仓库","categories":[],"tags":[{"name":"nodeJs学习笔记","slug":"nodeJs学习笔记","permalink":"http://yoursite.com/tags/nodeJs学习笔记/"}]},{"title":"MongoDB","slug":"mongodb","date":"2016-09-03T14:15:42.000Z","updated":"2017-03-01T12:55:09.951Z","comments":true,"path":"2016/09/03/mongodb/","link":"","permalink":"http://yoursite.com/2016/09/03/mongodb/","excerpt":"","text":"MongoDB数据库概念 数据库：一个电子化的文件柜 数据库就是为我们方便的管理数据的一个平台，例如对数据的存储、修改、查询等都非常的方便。 数据库分类数据库产品有很多，以下是一些常见的数据库产品： MySQL Oracle DB2 SqlServer MongoDB etc. 数据库没有排名之分，各有各的应用场景，我们这里学习的是 MongoDB 数据库。 MongoDB 数据库 为了更好的学习 MongoDB 数据库，大家可以参考菜鸟教程上的 MongoDB 数据库教程文档，链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.html MongoDB 数据库存储结构 安装与配置 MongoDB 数据库环境详情见视频：11_安装MongoDB数据库环境 启动 MongoDB 服务实例可以通过使用安装程序中的 mongod CLI应用程序来启动 MongoDB 服务。 直接在控制台输入：mongod 敲回车即可。 在启动的时候，可以通过 --dbpath 指定数据服务存储数据的目录，如果不指定该目录，默认 mongod 会去 c:/data/db 作为自己的数据存储目录。 64 位版本启动 MongoDB 数据服务： 1mongod --dbpath C:\\data\\db 32 位版本使用下面的命令启动数据服务： 1mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1 提示：如果不加 --dbpath, mongod 会自动使用 C:\\data\\db 目录作为自己的数据存储路径，所以，如果你已经有了 C:\\data\\db 目录了，可以省略 --dbpath。 执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了，千万不要关闭，否则无法连接，如果对数据库的操作结束，可以打开该控制台通过 Ctrl + C 关闭。 连接 MongoDB 数据服务注意：在进行连接之前请确保你的服务实例是开启状态的（不要关闭刚才开启的数据服务实例）。 打开一个新的控制台，在控制台输入以下命令用来连接本机的 MongoDB 服务实例： 1mongo mongo 命令默认去连接本机上的 MongoDB 服务实例：127.0.0.1:27017，可以通过下面的命令指定连接的主机名和端口号： 1mongo --host 127.0.0.1 --port 27017 如果看到类似于如下的字样说明连接成功： 123456789MongoDB shell version v3.4.0connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.0Server has startup warnings:2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten]2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten]&gt; 如果提示 “无法连接主机”，请检查你的 MongoDB 数据服务实例是否开启。 基本操作命令 show dbs 查看当前服务实例上所有的数据库 use 数据库名称 这个命令表示切换到指定的数据库 如果没有，也不会创建 如果已经有了，则表示切换到这个数据库对该数据库进行操作 db 查看当前所处的数据库 db.集合名称.insert(数据文档) show collections 查看当前数据库中所有的集合 db.集合名称.find() 查询指定集合中所有的数据 可以通过 db.集合名称.find().pretty() 美化输出格式 默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据 db.集合名称.update({更新条件}, {要更新的字段}) 更新指定集合数据 db.集合名称.remove({删除条件}) 删除指定集合中的数据 使用 Node 操作 MongoDB安装 MongoDB 官方提供的驱动包： 1npm install --save mongodb 具体操作方式请参考官方文档：https://www.npmjs.com/package/mongodb","categories":[],"tags":[{"name":"nodeJs学习笔记","slug":"nodeJs学习笔记","permalink":"http://yoursite.com/tags/nodeJs学习笔记/"}]},{"title":"express","slug":"express框架","date":"2016-09-01T10:13:42.000Z","updated":"2017-03-01T12:53:14.295Z","comments":true,"path":"2016/09/01/express框架/","link":"","permalink":"http://yoursite.com/2016/09/01/express框架/","excerpt":"","text":"package.json 文件package.json 文件一般用来描述项目的一些基本信息，例如入口文件、依赖项、项目介绍、开发作者等数据。 目前已知的两个非常重要的属性： main main 和模块化中的第三方包加载规则有关系 dependencies dependencies 和 npm 命令行工具有关系 当你安装包的时候，如果加上 --save 参数，则npm会自动把这个第三方包依赖信息写入到 package.json 文件中的 dependencies 字段中 当你执行 npm install 的时候，npm 会找到当前项目中的 package.json 文件中的 dependencies 依赖项，然后依次将所有的依赖下载下来 这个文件最好每一个项目都有，保存一些项目的基本信息。 这个文件可以通过 npm init 以向导的形式生成，也可以加上 -y 参数，一步生成。 Express 一个基于 Node 开发的一个快速 Web 开发框架主要用来构建 Server http://expressjs.com/ http://www.expressjs.com.cn/ hello-world12345678910111213141516171819202122var express = require('express')// 1. 调用 express 方法，得到一个类似于 server 的实例// 一般称作 appvar app = express()// 2. 通过 app 根据不同的请求方法及请求路径设定具体的处理函数// 当用户以 GET 请求 / 的时候，执行对应的回调处理函数app.get('/', function (req, res) &#123; res.end('hello world')&#125;)// 当用户以 GET 请求 /login 的时候，执行对应的回调处理函数app.get('/login', function (req, res) &#123; res.end('hello login')&#125;)// 3. 启动监听app.listen(3000, function () &#123; console.log('服务器已启动，请访问：http://127.0.0.1:3000/')&#125;) 处理静态资源 参考文档：http://www.expressjs.com.cn/starter/static-files.html 通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。 配置规则如下： 1app.use('路径访问前缀', express.static('资源目录路径')) 以下是一些配置示例： 将目录 static 资源暴露出来，可以通过 /static/* 的形式进行访问 app.use(&#39;/static/&#39;, express.static(&#39;static目录的绝对路径&#39;)) /static/css/a.css /static/css/b.css /static/img/ab2.jpg 将目录 public 资源暴露出来，不需要任何前缀就可以访问 app.use(express.static(&#39;public 目录的绝对路径&#39;)) /css/bb.css /img/a.jpg 将目录 demo 资源暴露出来，可以通过 /aa/* /aa前缀的形式进行访问 app.use(&#39;/aa/&#39;, express.static(&#39;demo 目录的绝对路径&#39;)) /aa/css/a.css /aa/**/*.* 将目录 static 资源暴露出来，可以通过 /static/* 或者 /aa/* 的形式进行访问 app.use(&#39;/aa/&#39;, express.static(&#39;static 目录的绝对路径&#39;)) app.use(&#39;/static/&#39;, express.static(&#39;static 目录的绝对路径&#39;)) 上面的形式就是把 static 目录中的资源提供了两种形式，既能以 /static/ 为前缀进行访问也可以以 /aa/ 的前缀进行访问 路由系统在 Express 配置使用 ejs 模板引擎Express 这个框架很精简，默认是不支持模板引擎的，需要配合一些第三方的模板引擎来结合使用，例如这里将 ejs 和 express 结合起来使用： 第一：安装 ejs： 1npm install --save ejs 第二：在代码中配置： 12app.set('views', 模板文件存储路径) // 注意，这里可以不配置，因为 Express 默认会去项目中的 `views` 目录进行查找app.set('view engine', 'ejs') // 这里表示让 Express 中的 res.render 方法使用 ejs 模板引擎，这里的 ejs 就是你安装的那个模板引擎的包名 只要经过了上面这种配置，然后 res 对象上就会自动多出一个方法：res.render ,使用方式和咱们之前自己封装的一样：res.render(&#39;视图名称&#39;, {要解析替换的对象数据}) 注意：使用了 ejs 模板引擎，默认视图文件后缀名必须是 .ejs，否则 render 方法找不到。如果想要修改，可以像下面这样： 1234// app.set('view enginge', 'ejs')// 将上面这句配置改为下面的形式，就修改了默认的 .ejs 后缀名app.engine('.html', require('ejs').__express)app.set('view engine', 'html') 在 Express 中配置使用 body-parser 插件解析处理表单 POST 请求体第一步：安装 body-parser 1npm install --save body-parser 第二步，在代码中进行配置： 12app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json()) 只要经过上面的安装配置，则在任意的 post 处理函数中都可以直接通过 req.body 来获取表单 POST 请求体数据。 例如： 1234app.post('login', function (req, res) &#123; // 这里可以直接通过 req.body 来获取表单 POST 请求体数据 console.log(req.body)&#125;) 中间件错误处理","categories":[],"tags":[{"name":"nodeJs学习笔记","slug":"nodeJs学习笔记","permalink":"http://yoursite.com/tags/nodeJs学习笔记/"}]},{"title":"node基础","slug":"node基础","date":"2016-08-26T13:18:22.000Z","updated":"2017-03-01T12:48:50.173Z","comments":true,"path":"2016/08/26/node基础/","link":"","permalink":"http://yoursite.com/2016/08/26/node基础/","excerpt":"","text":"1. Node.js 介绍1.1 网站开发模型（BS） Server 为客户端提交接口：数据 Java、.Net、Ruby、Python、PHP、Go、Swift、Lua 学 Node 本质不是在学 Node，在学 服务器（Web后台）编程 请求 处理 响应 大前端时代：JavaScript 语言也可以运行在服务器端 使用 JavaScript 这门语言也可以进行服务器编程 JavaScript 通过 Node.js 运行在服务器端 Browser 客户端：把一坨用户看不懂的数据变成友好的形式给用户体验 1.2 什么是 Node.js？ 简单的说 Node.js 就是运行在服务端的 JavaScriptNode开发就是利用 Ecmascript + 第三方开源库 + Node平台环境API进行编程 什么是 JavaScript JavaScript 一个运行在浏览器端的脚本原因 运行时：浏览器 Ecmascript：JavaScript 基本语法：var、if-else、for、Array、Object、String、function BOM Window DOM 渲染引擎 JavaScript 解析执行引擎 在所有浏览器中，Google Chrome 的 V8 引擎是最快的 JS 脚本代码解析执行引擎 通过 V8 引擎解析和执行 JavaScript 代码 Node 官网：https://nodejs.org/en/ Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js 是一个构建与 Chrome V8 引擎之上的一个 JavaScript 运行时（执行环境） Node 使用 JavaScript 进行编程 Node 采用了 Chrome 的 V8 引擎解析和执行 JavaScript 脚本代码 Node 不是一种语言，Node 可以用来解析和执行 JavaScript 代码 在 Node 没有 DOM、BOM 了，也不用去关心样式、结构问题了 Node 在基本的 JavaScript 语言之上，或者在 Node 平台给 Ecmascript 提供了大量的底层编程接口 例如文件IO 例如网络IO 处理数据 操作数据库 构建网络服务 。。。 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. event-driven：事件驱动 在 Node 中，也采用了类似于浏览器端的编程思想，事件模型编程思想 non-blocking I/O model：非阻塞IO模型 Node 中大量的通过类似于浏览器中 ajax 的方式进行编程 绝大多数代码都是异步编程模型 lightweight &amp; efficient：轻量和高效 Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node.js 包生态系统 Npm 是世界上最大的开源库生态系统 largest ecosystem：最大的开源库生态系统 1.3 使用 Node 可以做什么？ 开发网站服务器 游戏服务器 开发命令行工具 软件分为两种： GUI：看得见，鼠标点点点 CLI：命令窗口，各种命令，选项参数等 1.4 Node 发展史 Node.js 由 Ryan Dahl 和一些其他的开发者于2009年在 Joyent 工作时发明 Node 作者当初只是想做一个类似于 Apache 的服务器而已，最初的时候起的名字叫：webjs 2009年2月，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。 2009年5月，Ryan Dahl在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用。 2009年11月和2010年4月，两届JSConf大会都安排了Node.js的讲座。 2010年年底，Node.js获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node.js的发展。 2011年7月，Node.js在微软的支持下发布Windows版本。[2] 1.5 学习资源推荐 国内NodeJS开发者社区：https://cnodejs.org/ 《深入浅出Node.js》：作者：阿里巴巴.朴灵 2. 快速上手2.1 环境安装 https://nodejs.org/en/download/ 2.2 Hello World 当你在控制台输入：node 01-hello-world.js 之后 实际上通过你安装目录下的那个 node.exe 可执行程序读取了 01-hello-world.js 文件中的源代码 然后解析和执行文件中的代码 最后将结果打印输出到了控制台中 2.3 path 环境变量 目的：就是为了在终端的任意目录中都可以找到该可执行文件 配置方式： 一种在 path 中写路径，通过英文分号分隔 一种先定义变量，给一个变量值，然后在 path 中通过英文分号进行分隔，使用 %变量名% 引用该变量 2.4 文件操作2.5 HTTP 服务2.6 文件版留言本 3. Node 基础3.1 Node 中的 JavaScript console setInterval(callback, delay[, …args]) setTimeout(callback, delay[, …args]) clearInterval(intervalObject) clearTimeout(timeoutObject) clearImmediate(immediateObject) setImmediate(callback[, …args]) __dirname __filename module exports global process require() 3.2 模块化3.3 自定义模块（用户自己编写的模块） require module.exports exports 3.4 核心模块（Node 提供） 在线文档地址：https://nodejs.org/dist/latest-v6.x/docs/api/ 以下是常用的核心模块及作用： 核心模块名 作用 fs 文件操作 http 网络操作 net 更底层的网络操作 os 操作系统相关 path 文件路径操作 querystring 查询字符串处理 url url操作处理 3.5 第三方模块（也称作包）4. npm4.1 两层含义 npm 是一个网站，这个网站上托管了几十万个使用 JavaScript 开发的功能模块库 npm 是一个基于Node开发的一个终端命令行包管理工具 可以使用这个工具去 npm 网站上下载对应的库 4.2 npm 安装只要安装了 node 就有了 npm。 通过 npm -v 测试是否有 npm 工具。 4.3 使用 npm 安装包 找到能解决自己问题的包，看文档使用说明 通过 npm install 包名 下载到当前项目中的根目录 在代码中通过 require(&#39;第三方包名&#39;) 使用你下载的包 通过 npm install 包名 安装的包会自动下载到当前目录下的 node_modules 目录，如果该目录不存在，则直接创建，如果已存在，则直接将文件下载进去。 4.4 使用 Npm 安装全局命令行工具在 npm 社区中，除了有可以在项目中使用的第三方包之外，还有一些特殊的包：这些特殊的包被称之为命令行工具，不是用于项目的，而是可以安装到计算机中，然后通过命令行中的命令的形式来使用，这种工具有很多，例如：http-server、gulp、browser-sync、nodemon 等等等等很多。 安装方式： 1npm install --global 第三方命令行工具名字 卸载： 1npm uninstall --global 第三方命令行工具名称 查看全局命令行安装目录： 1npm root --global 5. Node 中的模块化5.1 模块通信交互规则 一个 JavaScript 文件就是一个模块 模块天生就是一个私有的作用域，默认模块内定义的变量等成员只能被模块内部访问 每一个模块中都有一个 module.exports 编程接口对象，默认是一个空对象 可以通过给 module.exports 编程接口对象添加成员向外暴露内部成员 例如：var foo = &#39;bar&#39; module.exports.foo = foo 上面示例标识当前模块向外部暴露了一个接口对象，内部有一个 foo 成员，值是 bar require 方法可以用来加载模块，该方法是同步加载执行的，主要做两件事儿 执行被加载模块中所有的代码 拿到被加载模块中的 module.exports 接口对象 5.2 用户自定义模块5.3 核心模块核心模块就是 Node 提供的模块，例如 fs、http、path。。。，这些模块其实也是文件模块，核心模块一般都是通过一个固定的标识名称进行加载的，也就是说不能写错，固定的。用什么就加载什么，无论是程序执行效率还是可维护性都非常好。 5.4 第三方模块也就是npm社区提供的第三方包，用的时候，先下载，然后也是通过 require 进行加载，加载第三方模块的时候，就是通过 require(&#39;第三方模块标识名&#39;)，所以第三方模块不可能有和核心模块重名的名称。","categories":[],"tags":[{"name":"nodeJs学习笔记","slug":"nodeJs学习笔记","permalink":"http://yoursite.com/tags/nodeJs学习笔记/"}]},{"title":"代码块及思路整理","slug":"代码块及思路整理","date":"2015-06-02T01:12:15.000Z","updated":"2017-02-28T16:00:38.220Z","comments":true,"path":"2015/06/02/代码块及思路整理/","link":"","permalink":"http://yoursite.com/2015/06/02/代码块及思路整理/","excerpt":"","text":"给a标签设置一个onclick=”return false;” 阻止其跳转 12345678910111213141516171819202122&lt;!--给a标签设置一个onclick=\"return false;\" 阻止其跳转--&gt;&lt;body&gt; &lt;a href=\"http://baidu.com\"&gt;百度&lt;/a&gt; &lt;!--给浏览器返回一个false就可以阻止跳转了--&gt; &lt;a href=\"http://baidu.com\" onclick=\"return false;\"&gt;通过JS阻止默认行为&lt;/a&gt; &lt;!--此时不跳转--&gt; &lt;a href=\"http://baidu.com\" onclick=\"return testAge(17);\"&gt;未满十八岁请走开&lt;/a&gt; &lt;!--此时不跳转--&gt; &lt;a href=\"http://baidu.com\" onclick=\"return testAge(18);\"&gt;满十八岁请进开&lt;/a&gt; &lt;!--此时跳转--&gt;&lt;script&gt; function testAge(age) &#123; if (age &gt;= 18) &#123; alert(\"欢迎\"); &#125; else &#123; alert(\"走开\"); return false; &#125; &#125; //必须是返回false 浏览器才认识 其他的 0、\"\"、null、undefined都不行&lt;/script&gt;&lt;/body&gt; 京东搜索框，没有输入任何东西时，失去焦点自动设置输入框中的值为默认；若输入框中的值是默认的，则获取焦点清空输入框。 123456789101112131415161718192021222324252627282930&lt;body&gt;&lt;input type=\"text\" id=\"txt\" value=\"金融\" class=\"cls\"/&gt;&lt;script&gt; var txt = document.getElementById(\"txt\"); //如果输入框里是金融，且类名为cls，此时获取焦点时要清空 txt.onfocus = function () &#123; if(this.value === \"金融\" &amp;&amp; this.className === \"cls\") &#123; this.value = \"\"; &#125; &#125;; //如果输入框中没有任何内容，失去焦点时，要在输入框中显示金融 //设置类名为cls，为获取焦点时清空输入框做准备 txt.onblur = function () &#123; if(this.value === \"\") &#123; this.value = \"金融\"; this.className = \"cls\"; &#125; &#125;; //按键抬起时，如果输入框中的内容不为空，则将它的类名清空 //即获取焦点时输入框中的内容不再清空 txt.onkeyup = function () &#123; if(this.value !== \"\") &#123; this.className = \"\"; &#125; &#125;;&lt;/script&gt;&lt;/body&gt; 排他思想 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt;&lt;div class=\"box\" id=\"box\"&gt; &lt;div class=\"hd\"&gt; &lt;span class=\"current\"&gt;体育&lt;/span&gt; &lt;span&gt;娱乐&lt;/span&gt; &lt;span&gt;新闻&lt;/span&gt; &lt;span&gt;综合&lt;/span&gt; &lt;/div&gt; &lt;div class=\"bd\"&gt; &lt;ul&gt; &lt;li class=\"current\"&gt;我是体育模块&lt;/li&gt; &lt;li&gt;我是娱乐模块&lt;/li&gt; &lt;li&gt;我是新闻模块&lt;/li&gt; &lt;li&gt;我是综合模块&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById(\"box\"); var spans = box.getElementsByTagName(\"span\"); var lis = box.getElementsByTagName(\"li\"); // 点击 上面的标签 要排他 for (var i = 0; i &lt; spans.length; i++) &#123; spans[i].index = i;//自定义属性 spans[i].onclick = function () &#123; //干掉所有人 for (var j = 0; j &lt; spans.length; j++) &#123; spans[j].className = \"\"; &#125; //留下我自己 this.className = \"current\"; var index = this.index; //干掉所有人 for (var k = 0; k &lt; lis.length; k++) &#123; lis[k].className = \"\"; &#125; //留下对应的 lis[index].className = \"current\"; &#125;; &#125;&lt;/script&gt;&lt;/body&gt; 自定义属性优化12345678910111213141516171819&lt;script&gt; var box = document.getElementById(\"box\"); var spans = box.getElementsByTagName(\"span\"); var lis = box.getElementsByTagName(\"li\"); for (var i = 0; i &lt; spans.length; i++) &#123; spans[i].setAttribute(\"index\", i); spans[i].onclick = function () &#123; for (var j = 0; j &lt; spans.length; j++) &#123; spans[j].removeAttribute(\"class\"); &#125; this.setAttribute(\"class\", \"current\"); var index = this.getAttribute(\"index\"); for (var k = 0; k &lt; lis.length; k++) &#123; lis[k].removeAttribute(\"class\"); &#125; lis[index].setAttribute(\"class\", \"current\"); &#125;; &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"前端学习中的零碎知识点","slug":"零碎知识点","date":"2015-05-05T04:30:21.000Z","updated":"2017-02-28T13:04:41.415Z","comments":true,"path":"2015/05/05/零碎知识点/","link":"","permalink":"http://yoursite.com/2015/05/05/零碎知识点/","excerpt":"","text":"在首页中引用样式表12&lt;link rel=\"stylesheet\" href=\"css/base.css\"/&gt;&lt;link rel=\"stylesheet\" href=\"css/index.css\"/&gt; 注意引用的顺序，base是公共样式，index是特定样式，特定网页的样式应该放在公共样式后面，以便对其进行覆盖常见布局 布局方式 固定布局 Fixed Layout 响应式布局 Responsive Layout 流式布局 Fluid Layout 栅格布局 Grid Layout 瀑布流布局 Waterfall Layout 圣杯布局 Holy Grail Layout:也称为双飞翼布局，特点是中间变化两边固定 清除浮动 什么是清除浮动 清除浮动，其实是清除当前元素周围的浮动元素，但是当前元素又不能影响别人，打不赢就跑，所以自己去下面独占一行了。 不浮动 float: none; clear: left/right/both; //清除左/右/全部 浮动 为什么要清除浮动 在布局的时候我们经常希望某些内容能够水平排布，水平排布后，由于内部内容不确定，高度不能简单的给一个定值。而如果不给高度，子元素又都浮动了，父盒子就会因为没有子盒子的支撑而塌陷。 利用清除浮动的这个特性，我们可以给父元素中最后一个不浮动的盒子使用 clear:both; 从而把父盒子的高度撑起来，并且能够根据内部内容的变化而改变高度。 清除浮动的方式 额外标签法 原理：单独使用一个标签加上clear:both跑到浮动元素下面，从而消除子盒子浮动造成的父盒子塌陷。 优点：通俗易懂，容易掌握 缺点：添加很多无意义的空标签，不符合结构与表现分离的原则，不利于后期维护 父元素设置 overflow：hidden 原理：让父盒子形成BFC，BFC的特性之一就是可以承载浮动元素 优点：不存在结构和语义化问题，代码量极少缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素 单伪元素 1234567891011.clearfix:after &#123; content: \"\"; height: 0; visibility: hidden; overflow: hidden; dispaly: block; /*不是inline就行*/ clear: both;&#125;.clearfix &#123; *zoom: 1; /*IE67*/&#125; 双伪元素 12345678910.clearfix:before, .clearfix:after &#123; content: \"\"; display: table;/*不是inline就行*/&#125;/*在有该类的元素内部元素的前面和后面添加元素*/.clearfix:after &#123; clear: both;&#125;/*只要after两侧有浮动元素，after就会跑到最下面，从而撑开带有该类名的父盒子*/.clearfix &#123; *zoom: 1;&#125; /*用于兼容IE/7/6*/ 注：用display:table是因为display:block伪元素仍然有宽度加了一个before是为了防止外边距合并通常说的清除浮动，指的是闭合浮动，即：清除子元素的浮动对父元素造成的影响。 BFC block formatting content 块格式化上下文，是w3c规定的一种独立渲染区域 特性为 BFC 会阻止外边距折叠 BFC 可以承载浮动的元素 BFC 可以阻止元素被浮动元素覆盖 触发BFC的情况： float 除了none以外的值（left，right） overflow 除了visible 以外的值（hidden，auto，scroll） display (table-cell，table-caption，inline-block) position（absolute，fixed） 根元素 圆角 CSS3属性，用于向元素添加圆角边框12345border-top-left-radius:2px;border-top-right-radius:2px;border-bottom-right-radius:2px;border-bottom-left-radius:2px;border-radius:2px;/*为简写形式，等价于以上代码顺序从左上角开始顺时针设置*/ 例如，一个盒子的 width: 10px; 设置 border-top-left-radius:10px;结果是半径为10px的1/4圆，左上角是圆弧。如果设置 border-radius:5px; 结果是直径为10px的圆。 网页构建策略 两种网站构建策略：渐进增强 progressive enhancement：先针对低版本浏览器做基本功能，再针对高版本浏览器去美化和增强。此策略一般用于PC端（PC端仍然有很多老版本浏览器）;优雅降级 graceful degradation：先针对高版本浏览器做最完整的功能，再针对低版本的浏览器进行修补，此策略一般用于移动端（移动端浏览器普遍比较新）;","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"jQuery学习笔记","slug":"jQuery基础","date":"2015-04-10T13:42:10.000Z","updated":"2017-02-28T13:03:20.556Z","comments":true,"path":"2015/04/10/jQuery基础/","link":"","permalink":"http://yoursite.com/2015/04/10/jQuery基础/","excerpt":"","text":"为什么学jQuery jQuery是什么 jQuery是JS的一个库，封装了开发过程中常用的功能，能够提高开发效率。 JS库就是把常用的代码放到一个单独的文件中，用的时候直接引用到页面里面就可以了。 使用jQuery 使用步骤：1.引包；2.写入口函数；3.实现功能（事件处理）； 入口函数就是指程序运行的时候最开始调用的函数，也就是程序开始的地方。 使用jQuery 版本介绍 最常用的两个版本： 1.12.x和最新推出的3.0.03.0版本不支持IE6/7/8 PC端的开发主要使用1.12.x版本 未压缩版（开发版）：代码可读性高，推荐在开发和学习环境中使用，方便查看源代码； 压缩版：去除了注释、换行、空格，并且将一些变量替换成了a,b,c之类的简单字符，基本没有可读性。推荐在生产和测试环境中使用，因为文件较小，减少网络压力。 引包注意 在使用jQuery之前，先把jQuery文件引到页面中来，如果在使用jQuery之前，没有引用jQuery文件，会报错； src路径一定要写正确 如果src路径写错，也会报错 入口函数 jQuery入口函数第一种：`$(document).ready(function() {函数主体});` 第二种：`$(function(){函数主体});` 以上两种写法，作用完全相同，用哪个都可以。 JS的入口函数`window.onload = function(){函数主体};` jQuery入口函数和JS入口函数的区别 书写个数不同 JS入口函数只能出现一次，出现多次会存在事件覆盖的问题。 jQuery的入口函数，可以出现任意多次，不会覆盖。 执行时机不同 JS入口函数是在所有资源加载完成后，才执行。（包括：页面、外部js文件、外部css文件、图片等） jQuery入口函数，是在文档加载完成后就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。 $符号 $ 就是一个普通的字符，可以用于变量名或函数名 JS命名规范允许出现的字符有：数字、字母、下划线、$。 123456var $ = \"字符串\";var $ = 123;function $()&#123; alert(\"我是函数'$'\");&#125;$(); // 调用上面我们自定义的函数$ **jQuery中的$实际是一个函数** 12345// jQuery中使用$的主要场景$(document）.ready(function()&#123;&#125;); // 调用入口函数$(function()&#123;&#125;); // 调用入口函数$(\"#btnShow\") // 获取id属性为btnShow的元素$(\"div\") // 获取所有的div元素 注意： jQuery里面的$函数，根据传入参数的不同，进行不同的调用，实现不同的功能。返回的是jQuery对象 jQuery这个JS库，为了避免冲突，给这个最重要的$函数还起了另外一个名字：jQuery jQuery函数跟$函数的关系：jQuery === $; jQuery对象 jQuery对象与DOM对象 DOM对象此处指的是：使用JS操作DOM的方法返回的对象 var btn = document.getElementById(“btnShow”); //普通的DOM对象 jQuery对象此处指的是：使用jQuery操作DOM的方法返回的对象 var $btn = $(“#btnShow”); // Query的DOM对象 jQuery拿到普通的DOM对象后会对其进行包装，让其成为具有jQuery方法的jQuery对象 jQuery对象转DOM对象 第一种方式 var btn1 = $btn[0]; //通过索引的方式把DOM对象取出来（推荐使用此方式） 第二种方式 var btn2 = $btn.get(0);//调用get()方法也可以 这两种方式使用哪一种都可以 DOM对象转jQuery对象 $(普通的DOM对象) //直接加一个$符号 jQuery选择器 JS中选择DOM元素的方法 考虑兼容性的话，JS提供的选择DOM的方法只有两个： document.getElementById();//通过id属性获取指定元素,返回唯一的DOM对象 document.getElementsByTagName();//通过标签名获取指定元素,返回DOM对象数组（即使只有一个元素）. jQuery选择器 基本选择器| 符号（名称） | 说明 | 用法 || :————: | :————: | :————: || # | Id选择器 | $(“#btnShow”).css(“color”, “red”);选择id为btnShow的一个元素（返回值为jQuery对象，下同） || . | 类名选择器 | $(“.liItem”).css(“color”, “red”);选择含有类liItem的所有元素 || 标签名 | 标签选择器 | $(“li”).css(“color”, “red”);选择标签名为li的所有元素 || ,隔开 | 并集选择器 | $(“div,p,li”).css(“color”, “red”);div、p、li都会被选中 || 紧挨着 | 交集选择器 | $(“li.current”).css(“color”, “red”);选择标签名为li并且类名为current的元素 | | 层级选择器| 符号（名称） | 说明 | 用法 || :————: | :————: | :————: || 空格 | 后代选择器 | $(“#j_wrap li”).css(“color”, “red”);选择id为j_wrap的元素的所有后代元素li || &gt; | 子代选择器 | $(“#j_wrap &gt; ul &gt; li”).css(“color”, “red”);选择id为j_wrap的元素的所有子元素ul的所有子元素li | 常用的过滤选择器| 符号（名称） | 说明 | 用法 || :————: | :————: | :————: || :eq(index) | 选择匹配元素中索引号为index的一个元素，index从0开始 | $(“li:eq(2)”).css(“color”, ”red”);选择li元素中索引号为2的一个元素 || :odd | 选择匹配元素中索引号为奇数的所有元素，index从0开始 | $(“li:odd”).css(“color”, “red”);选择li元素中索引号为奇数的所有元素 || :even | 选择匹配元素中索引号为偶数的所有元素，index从0开始 | $(“li:odd”).css(“color”, “red”);选择li元素中索引号为偶数的所有元素 | 筛选选择器（都是方法）| 符号（名称） | 说明 | 用法 || :————: | :————: | :————: || find(selector) | 查找指定元素的所有后代元素（子子孙孙） | $(“#j_wrap”).find(“li”).css(“color”, “red”);选择id为j_wrap的所有后代元素 || children(selector) | 查找指定元素的直接子元素（亲儿子元素） | $(“#j_wrap”).children(“ul”).css(“color”, “red”);选择id为j_wrap的所有子代元素ul || siblings(selector) | 查找所有其他的兄弟元素（不包括自己） | $(“#j_liItem”).siblings().css(“color”, “red”);选择id为j_liItem的所有兄弟元素 || next(selector) | 查找下一个兄弟元素 | $(“#j_liItem”).next().css(“color”, “red”);选择id为j_liItem的下一个兄弟元素 || parent(selector) | 查找父元素（亲的） | $(“#j_liItem”).parent(“ul”).css(“color”, “red”);选择id为j_liItem的父元素 || eq(index) | 查找指定元素的第index个元素，index是索引号，从0开始 | $(“li”).eq(2).css(“color”, “red”);选择所有li元素中的第二个 | jQuery中的DOM操作 样式操作 获取样式 $(selector).css(&quot;font-size&quot;);//参数表示要获取的样式 属性名称，返回”font-size”样式属性对应的值。 设置样式 设置单个样式： $(selector).css(&quot;color&quot;,&quot;red&quot;);//属性为：参数名，参数值 设置多个样式 $(selector).css({&quot;color&quot;:&quot;red&quot;,&quot;font-size&quot;:&quot;30px&quot;});//参数为对象 类名操作 为指定元素添加类名 addClass(className);$(selector).addClass(&quot;liItem&quot;);//不需要加点，只传名字 为指定元素移除类名 removeClass(className)$(selector).removeClass(“liItem”);//移除指定类名$(selector).removeClass(); //不指定参数，表示移除所有类名 判断是否包含某个类名 hasClass(calssName)$(selector).hasClass(“liItem”);//返回true或false 切换类名 toggleClass(className)$(selector).toggleClass(“liItem”);//切换类名，如果没有指定类名就添加，有就移除。 动画函数 显示隐藏动画show()方法 形式一： // 不带参数，没有动画 $(selector).show();//作用等同于css(“display”, ”block”) 形式二： //参数为数值，表示：执行动画时长 $(selector).show(2000);//单位为毫秒（ms），2000毫秒即2秒 形式三： //参数为字符串，是jQuery预设的值，共有三个，分别是：slow、normal、fast $(selector).show(“slow”); //slow：600ms、normal：400ms、fast：200ms 形式四： // 参数一可以是数值类型或者字符串类型 // 参数二表示：动画执行完后立即执行的回调函数 $(selector).show(2000, function() {}); hide()方法 1234 $(selector).hide(); $(selector).hide(1000); $(selector).hide(“slow”); $(selector).hide(1000, function()&#123;&#125;); 显示隐藏切换 $(selector).toggle(speed,callback); jQuery预设的三组动画效果的语法几乎一致： 参数可以有两个，第一个是动画的执行时长(可以是指定字符或毫秒)，第二个是动画执行完成后的回调函数。 - 滑入滑出动画 滑入效果 作用：让元素以下拉动画效果**展示**出来 `$(selector).slideDown(speed,callback);` 滑出效果 作用：让元素以上拉动画效果**隐藏**起来 `$(selector).slideUp(speed,callback);` **滑入滑出切换** `$(selector).slideToggle(speed,callback);` - 淡入淡出动画 **淡入效果** 作用：让元素以淡淡的进入视线的方式**展示**出来 `$(selector).fadeIn(speed, callback);` **淡出效果** 作用：让元素以渐渐消失的方式**隐藏**起来 `$(selector).fadeOut(1000);` **淡入淡出切换** 作用：通过改变不透明度，切换匹配元素的显示或隐藏状态 `$(selector).fadeToggle(&apos;fast&apos;,function(){});` **淡淡达到效果** 改变不透明度到某个值 `$(selector).fadeTo(0, .5)；` 作用：调节匹配元素的不透明度 与淡入淡出的区别：淡入淡出只能控制元素的不透明度从 完全不透明 到完全透明；而fadeTo可以指定元素不透明度的具体值。并且时间参数是必需的！ // 用法有别于其他动画效果 // 第一个参数表示：时长 // 第二个参数表示：不透明度值，取值范围：0-1 $(selector).fadeTo(1000, .5); //0全透，1全不透 // 第一个参数为0，此时作用相当于：.css(“opacity”, .5); $(selector).fadeTo(0, .5); - 动画方法总结 ![mark](http://olvlhfr9r.bkt.clouddn.com/blog/20170228/210311396.jpg)","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"几个小专题","slug":"专题","date":"2015-04-02T10:12:25.000Z","updated":"2017-02-28T13:00:19.729Z","comments":true,"path":"2015/04/02/专题/","link":"","permalink":"http://yoursite.com/2015/04/02/专题/","excerpt":"","text":"阻止a标签跳转1234567&lt;a href=\"#\"&gt;a&lt;/a&gt;&lt;!--点击后会跳到当前页面的头部--&gt;&lt;a href=\"#id\"&gt;a&lt;/a&gt;&lt;!--会跳转到指定标签的位置--&gt;&lt;a href=\"###\"&gt;a&lt;/a&gt;&lt;!--在数据库中有的时候会被当作注释--&gt;&lt;a href=\"javascript:\"&gt;a&lt;/a&gt;&lt;a href=\"javascript:;\"&gt;a&lt;/a&gt;&lt;a href=\"javascript:void(0)\"&gt;a&lt;/a&gt;&lt;a href=\"javascript:void(0);\"&gt;a&lt;/a&gt; 半透明123background-color: rgba(255, 0, 0, 0.5);/*透明度不继承*//*0-1 0全透明 1不透明*//*IE8不支持*/opacity: 0.5;/*透明度会继承*//*0-1 0全透明 1不透明*//*IE8不支持*/filter: alpha(opacity=20);/*0-100 0全透明 100不透明*//*只有IE678支持*/ 显示隐藏盒子1234567891011121314151617//rgba//opacity//filter//display//visibility//overflow也行//h0//w0//w0h0//定位 left//定位 top//m-很大//m 很大//定位 把他盖住//浮动 把他盖住//改变背景色 和后面的背景色一样//从结构上把他干掉","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"CSS3学习笔记","slug":"CSS3","date":"2015-03-26T12:18:43.000Z","updated":"2017-02-28T12:55:14.334Z","comments":true,"path":"2015/03/26/CSS3/","link":"","permalink":"http://yoursite.com/2015/03/26/CSS3/","excerpt":"","text":"CSS学习笔记 属性选择器 1234567 E[att]:包含attr属性，判断是否拥有某个属性 E[att=&quot;val&quot;]:属性值为val。属性是否等于val，属性的值 可以写单引号、双引号，也可以省略 E[att~=&quot;val&quot;]:属性值使用空格进行分割,有一个为val E[att^=&quot;val&quot;]:属性值以val开头 E[att$=&quot;val&quot;]:属性值以val结尾 E[att*=&quot;val&quot;]:属性中包含val的属性，可以是单个，也可以是多个。 E[att|=&quot;val&quot;]:属性以‘-’分割，其中有val值（如果属性只有val 那么也会被选中哦） 兄弟选择器 作用：选择相邻的兄弟节点 语法：选择器1~选择器2 指的是，在相同父元素中，选择器1之后的，所有满足选择器2 的元素。 伪类选择器 语法： 一个冒号（：） 注意： 1.标签E,必须是某个元素的子元素(在界面上) 2.如果通过`伪类选择器`找到的元素不是`E`则选择无效 12345678910111213141516171819202122 结构伪类 1.下面的这几个方法，如果有其他的兄弟元素，会一并考虑进去 E:first-child：第一个子元素 E:last-child：最后一个子元素 E:nth-child(4): nth-child 如果给的是 索引 是从1开始。nth-child使用的时候，如果前面有其他的元素，也会计算进去索引 E:nth-child(n)： 第n个子元素，计算方法是E元素的全部兄弟元素； E:nth-last-child(n)： 跟E:nth-child(n)类似 ，只是倒着计算； 其中n的取值范围是：0，1,2,3,4...线性累加 可以传入表达式，比如2n,2n+1等等 可以传入特殊字符：even(偶数) odd(奇数) 2.不考虑兄弟元素的 伪类选择器 E:first-of-type：第一个子元素 E:last-of-type:最后一个子元素 E:nth-of-type(4):索引从1开始，指的是第4个元素，不考虑兄弟元素。 E:nth-of-type(n+4):n从0开始。指的是索引第4个以后得所有元素。 3.empty选择器 E:empty 指的是E标签，并且内容为空（空格、换行也不能有）。 4.not选择器 E:not(选择器)：指的是，不满足括号内选择器条件的元素E。括号的内部，写的还是选择器。可以写属性选择器,伪类选择器等等。 例如：li:not([name])：li标签,没有name属性的全部获取. 目标伪类 E:target:选中当前锚点 伪元素选择器 作用： 在不改变页面html结构的基础上,为其添加标签 基本的语法为：两个冒号。也可以写一个冒号，但不建议。 例如， ::before表示在标签之前； ::after表示在标签之后； ::first-line表示第一行；可以自适应宽度。 ::first-letter表示第一个字母 ::selection表示选中的内容，* 只能设置的属性有`background-color`,`color`,`text-shadow` ::placeholder 设置`input`标签`placeholder`属性的显示颜色 注意：设置的是 input标签中的 placeholder属性的样式 完全按照标准 但是却无法生效 该样式 还处于测试阶段 需要添加一些 前缀 可以使用帮助文档 里面的提示 进行编写 如果 要兼容老实的浏览器 可以选用 js的方式去写 修改value值 以及 style属性 获取焦点事件 失去焦点事件 content 只要设置了 就能够看到内容不受限制，可以写空字符串 伪元素是行内元素，为了设置宽高，需要变为块级元素display:block;position:absolute; 伪元素其实相当于是子元素，即普通的行内元素，所以单标签不支持伪元素。 边框圆角 border-radius; 符合属性，特点： 1.给一个值，四边都有圆角； 2.给两个值，前面的设置的是左上和右下，后面设置的是右上和左下； 3.给三个值，第一个是左上，第二个是右上和左下，第三个是右下； 4.给四个值，顺序为左上、右上、右下、左下； 分开写： `border-top-left-radius;`//左上角 `border-top-right-radius;`//右上角 `border-bottom-right-radius;`//右下角 `border-bottom-left-radius;`//左下角 过渡属性 transition 适用于所有元素，包含伪元素before和after。设置的时候，要写上： *,::before,::after { transition: all 2s 3s; } transition-property: background-color,height,border;//过渡的属性，支持连写。基本上所有的属性 都支持 过渡。//如果我们想要为不同的过渡属性 指定不同的过渡时间,延迟时间，就只能使用这种分开的写法 transition-duration: 2s,5s;//过渡持续的时间,支持连写 transition-delay: 0s,2s;//延迟时间，支持连写 transition-timing-function: linear;//线型 设置速度 支持的速度设置选项 有几种 ease ease-in ease-out ease-in-out linear 实际开发中 我们不会用过渡 去做很长时间 效果 对于 时间很短的 过渡效果 直接不设置 使用默认的 ease 即可 用户 肉眼是看不出来的 复合写法如果是所有属性,都支持过渡,那么 直接写一个all即可.transition: all 2s 3s;//所有的属性 都支持过渡 时间为2s 延迟3s钟如果在默认的状态下添加，那么hover开始以及结束都会触发；如果在hover中添加，则只有hover的状态下应用该样式 ,鼠标离开之后，立刻还原； 设置颜色 rgb(0, 0, 0);//可以继承，不能设置透明度，取值为0-255 rgba(0, 0, 0, .5);//可以继承，前三个参数取值为0-255，最后一个参数表示透明度，取值0-1 hsl(296, 90%, 39%);//不可以继承，可以跟rgb互相转换，不能设置透明度 hsla(296, 90%, 39%, .5);//不可以继承，最后一个参数是设置透明度 文字阴影 text-shadow(); 文字阴影： 阴影的方向 x跟y 参数1: x的移动值 正方向是 右; 参数2: y的移动值 正方向是 下; 参数3: 设置影子的 放大; 参数4: 颜色; 注意: 阴影的颜色 不设置 默认黑色 影子的大小 默认是跟 文字一样大 如果只想设置文字的放大 必须要 将 x 跟y的移动值 进行设置 10px red 支持过渡 text-shadow: 1px 1px 1px red; 盒子阴影 box-shadow(); 盒子阴影 参数0: inset 向内阴影（可选） 参数1: x →向右是正向 参数2: y ↓向下是正向 参数3: 模糊的程度;(可选) 参数4: 直接放大影子 不会模糊(可选) 参数5: 颜色;(可选) 注意: 默认颜色为黑色; 支持写 多个影子 支持过渡 一般影子 就给一丢丢即可 并且是模糊的 box-shadow: 0 20px 20px gray; 渐变（颜色） 线性渐变 (就是朝着某个方向发生进行渐变)linear-gradient(); /*语法组合方式 可以添加多个颜色*/ background-image: linear-gradient(方向,开始颜色 开始位置 ,颜色2 开始位置,颜色3 开始位置.....); 参数1: 方向 1.可以直接写 to 方向 to 方向1（方向2 ....） 2.可以直接写角度：45deg... 参数2: 颜色1; 参数3: 颜色2; ...可以继续往后写颜色 background: linear-gradient(to top,skyblue,white);//自下而上,从skyblue渐渐变为white;background: linear-gradient(to top left,skyblue,white);//自右下到左上,颜色从skyblue渐渐变为white;background: linear-gradient(45deg,skyblue,hotpink);//方向朝着顺时针45度角,颜色从skublue渐变为hotpink;background: linear-gradient(45deg,skyblue,hotpink,purple,orange,yellow);//方向朝着顺时针45度角,颜色从skyblue到hotpink再到purple再到orange再到yellow;background-image: linear-gradient(45deg,red 10px,yellow 20px);//朝着 顺时针45度 红色到 10px结束 黄色从 20px开始;background-image: linear-gradient(45deg,red 10%,yellow 20%);//朝着 顺时针45度 红色到10%结束 黄色从 20%开始; 径向渐变 (以某个点作为圆心,向四周扩散的渐变)radius-gradient()； 设置的是一个 圆形(椭圆形)的 渐变 参数1: 半径;（只设置一个值，得到一个圆；设置两个值，得到椭圆） 参数2: 圆的位置;（at center) 参数3: 颜色1; 参数4: 颜色2; .... background-image: radial-gradient(500px 200px,red,yellow);//background-image: radial-gradient(500px 200px at center ,red,yellow);//background: radial-gradient(100px 200px,red 10%,green 10%);//横向半径100px 红色10% 绿色20%background: radial-gradient(100px 200px,red 10px,green 20px);//横向半径100px 红色10px 绿色 20px 注意： 渐变生成的是 图片 不能设置给 backgroundcolor,要设置给background-image; background-image: linear-gradient(to top left,skyblue,white); 渐变属性 不支持颜色过渡(*) 支持 background-position过渡 由于是CSS3的样式兼容性 较差 目前实际开发中 渐变使用较少 主流还是 使用图片 转换 transform如果 使用 多个transform属性编写 下面的会 覆盖上面 平移 translate(); 使用变换的时候 可以理解为 脱离标准流 浮动流... 不影响其他的元素 移动 x的正方向是 → y的正方向是 ↓ transform: translateX(100px);//分开设置 transform: translateY(100px); transform: translate(100px, 100px);//合写 transform: translateX(100px) translateY(100px);//合写 缩放 scale() 缩放支持两个轴向的缩放:x 跟 y scale(0, 0) 参数1: x; 参数2: y; 传递的值 不是一个 具体的像素 而是缩放的比例 即取值为0-1的小数 transform: scaleX(.5); transform: scaleY(.5); transform: scaleX(.5) scaleY(.5); transform: scale(.5, .5); 旋转 rotate() 默认的旋转中心为盒子的中心，使用transform-origin来设置旋转的中心。 transform-origin: top right; 旋转的单位，建议使用deg（度） transform: rotate(180deg); 扭曲 skew() 参数1: x; 参数2: y; 单位deg（度） 一般情况下，建议给一个参数。两个参数不好控制。 transform: skewX(30deg); transform: skewY(30deg); transform: skew(30deg, 30deg); 盒子模型 box-sizing 取值有两个： 1.border-box: 优先保证 自己所占区域的大小不变 设置 border和padding，不会改变自己整体的大小 只会把里面的内容缩小，来保证整个盒子的大小不变 2.content-box 优先保证里面内容区域(content)的大小不变 添加border,padding的时候 自己整个的会变大，即整个盒子会变大 默认的是 content-box","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"THML5基础知识","slug":"HTML5","date":"2015-03-17T14:03:23.000Z","updated":"2017-02-28T12:53:23.654Z","comments":true,"path":"2015/03/17/HTML5/","link":"","permalink":"http://yoursite.com/2015/03/17/HTML5/","excerpt":"","text":"THML5基础知识 HTML5和H5的区别 H5包含三个部分：HTML5； CSS3; JavaScript； DOCTYPE的作用 一个标准的HTML文档,开头第一句都应该是&lt;!DOCTYPE&gt;,根据不同的HTML版本,内容上会有差别.DOCTYPE并不是HTML标签,而是一个声明。 作用: 告诉浏览器编写页面所用的标记的版本. 通俗一点:高速浏览器按照什么来解析页面。 DOCTYPE写法_HTML4中 在HTML4.01中有三种DOCTYPE声明，分别是： 1.HTML 4.01 Strict Emmet语法为: html:4s+tab 1 &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt; 2.HTML 4.01 Transitional Emmet语法为: html:4t tab 12 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; 3.HTML 4.01 Frameset 没有找到对应的Emmet语法 12 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; DOCTYPE写法_HTML5中 Emmet语法为:html:5或！tab Emmet语法创建文档结构 * `html:5`或`!`：HTML5文档类型 * `html:xt`：XHTML过渡型文档类型 * `html:xs`：XHTML严格型文档类型 * `html:4t`：HTML4过渡型文档类型 * `html:4s`：HTML4严格型文档类型 语义标签原来使用div+class的格式htlm5新语义标签： header、main、footer、nav、aside、article、section 有兼容性问题，解决办法： 方法1:js代码 在页面中添加创建header标签的代码 修改header的样式,添加display:block 123456789101112 &lt;style&gt; header&#123; height: 100px; background-color: orangered; /*在低版本的ie中,如果想要显示h5的新语义标签,需要设置为block*/ display: block; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; // 使用代码创建header标签 document.createElement(\"header\"); &lt;/script&gt; js框架 直接导入js框架,js框架内部干的事情类似于我们刚刚写的js代码,但是处理的逻辑会多一些。 123 &lt;!--使用js框架来解决html5新语义标签的方法--&gt; &lt;script src=\"js/html5shiv.min.js\"&gt; &lt;/script&gt; 优化代码执行–hack写法无论是js,或者js框架都需要执行js代码才能够解决兼容性问题,但是在高版本的浏览器中,那段js代码就没有必要执行了,所以我们通过一个叫做[hack]的方式来减少性能的浪费用法：使用 hack语法 将需要执行的js的代码包裹起来 123456 //lte： less than equel &lt;!--[if lte IE 8]&gt; &lt;script&gt; alert(\"这段js代码执行了\"); &lt;/script&gt; &lt;![endif]--&gt; 1234567 &lt;!--在低版本的 ie中 完成 创建 标签的 功能 并且会自动添加上 display block 有多个的话 也会 自动帮助我们生成 --&gt; &lt;!--使用条件注释 让 下列js文件 只在 低版本的 ie中 导入--&gt; &lt;!--[if lte IE 8]&gt; &lt;script src=\"js/html5shiv.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;![endif]--&gt; 新type属性 color //页面上显示一个颜色选择框 date //页面上显示一个可以选择日期的框 number //只能输入数字 email //键盘会带有\\@符号 search//键盘会有搜索按钮 tel //键盘会只显示数字 range //页面上显示一个可拖动的滚动条，可以用来显示进度 month //显示年和月 week //显示年和周 新表单属性 placeholder //输入框中默认显示的文字 autofocus //自动获取焦点 multiple //上传文件可以多选 autocomplete //自动完成 必须满足两个条件：首先 input 必须有 name属性 form表单 必须 提交过，点击submit按钮 pattern //设置正则表达式，规范输入的内容 required //非空验证 oninvalid事件，验证失败以后触发 oninput事件，input内容改变时触发 setCustomValidity()设置默认提示信息 获取dom元素 querySelector()方法 只能找到 匹配的第一个 从上往下找； querySelectorAll(‘li’);返回的是 数组，哪怕只有一个元素 也是 数组； 新表单元素 datalist；该元素规定了输入区域的选项列表,可以让用户有一些选项。 1234567891011 &lt;!--可以指定一些选项 input 通过list属性关联 datalist 需要设置id属性 --&gt; &lt;form action=\"\"&gt; &lt;input type=\"tel\" list=\"telList\" placeholder=\"请输入电话号码\"/&gt; &lt;datalist id='telList'&gt; &lt;option value=\"1888888\"&gt;&lt;/option&gt; &lt;option value=\"1999999\"&gt;&lt;/option&gt; &lt;/datalist&gt; &lt;/form&gt; 多媒体标签 视频标签：video src 指定播放的视频 autoplay 自动播放 controls 控制器 width、height 宽高设置的是 video标签的 大小，内部的视频还是优先考虑自己的缩放，保证观影效果。 loop 循环 缺点：视频可以直接另存为 移动端 使用video标签居多 桌面端 使用flash居多 音频标签：audio src:音频的地址 controls:音频播放控制器 autoplay:自动播放 loop:循环 12 &lt;audio src=\"song.ogg\" controls=\"controls\" autoplay loop&gt; &lt;/audio&gt; 兼容问题 通过source属性，可以指定多种格式的视频或音频 浏览器会从上往下解析，能够播放即开始播放，后面的视频或音频就不考虑了； 123456 &lt;video controls autoplay loop width='200px' height='300px'&gt; &lt;source src=\"movie/movie04.ogg\"&gt;&lt;/source&gt; &lt;source src=\"movie/movie.mp4\"&gt;&lt;/source&gt; 亲爱的用户,你的浏览器版本太低了,请立刻升级,建议下载谷歌浏览器 &lt;a href=\"#\"&gt;点我,点我.点我&lt;/a&gt; &lt;/video&gt; class操作 classList；通过dom元素获取，返回的是一个对象，里面有多种操作class的方法： add 增加class remove 移除class。若要移除多个，分别用引号引起来，中间用逗号隔开。 contains 判断是否存在 toggle 切换 自定义属性HTML5中 推出了一个 推荐的 数据格式data-* data-xxx-xxx-xxx 只要我们需要 可以一直往后写 实际生成的时候，会去掉 第一个data- 后面的中间的 - 去掉，字母变为大写。比如： data-meat-one ---&gt; meatOne 属性可以使用大写，但是最终生成的对象，会使用小写字母 所有通过 data-添加的属性 都保存在 dataset这个属性中 可以通过.语法获取，也可以通过[]来获取 进度条progress标签和meter标签&lt;progress value=&#39;.5&#39;&gt;&lt;/progress&gt;&lt;meter&gt;&lt;/meter&gt;可以使用自定义的方式 保证 页面的显示效果","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"BOM","slug":"BOM","date":"2015-03-09T11:10:35.000Z","updated":"2017-02-28T12:51:08.820Z","comments":true,"path":"2015/03/09/BOM/","link":"","permalink":"http://yoursite.com/2015/03/09/BOM/","excerpt":"","text":"BOM浏览器对象模型 window对象 window对象是JavaScript中的顶级对象 所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window onload();//窗体加载完成事件（窗体加载完成才执行） window.open(url,target,param); url 要打开的地址； target新窗口的位置；_blank _self _parent(父框架) param 新窗口的一些设置； 返回值，新窗口的句柄,返回一个窗体对象，可供close()调用； window.close(); 关闭窗口,谁调用就关闭谁 定时器 定时执行 var timerId = setInterval(function(){},delay); clearInterval(timerId);//间隔时间执行，不是特别精确 延迟执行 var timerId = setTimeout(function(){},delay); //设置定时器 setTimeout 参数 1回调函数 2延迟时间（单位是毫秒） 返回值 数字，即定时器的编号 clearTimeout(timerId);//清除定时器 参数是数字，即要清除的定时器 location对象 window.location– location相当于浏览器地址栏– 可以将url解析成独立的片段 location对象的属性– href– location.reload(); //重新加载 screen对象navigator对象history对象 历史记录管理 后退 history.back(); history.go(-1) 前进 history.forward(); history.go(1); Date对象 var date = new Date(); //创建日期对象 date.valueOf(); //从1970-1-1 00:00:00:000 到现在的毫秒数 var date2 = Date.now(); //直接返回的就是当前时间的毫秒值,IE9+才支持 var date3 = +new Date(); // 不支持now的方法 日期格式化： var date = new Date(); console.log(date.toDateString());//Sun Nov 06 2016 console.log(date.toTimeString());//20:19:19 GMT+0800 (中国标准时间) console.log(date.toLocaleDateString());//2016/11/6 console.log(date.toLocaleTimeString());//下午8:19:19 12345678date.getYear();//返回年date.getMouth();//返回月份，0-11date.getDate();//返回当天是当月的第几天date.getDay();//返回星期几， 0-6date.getHours();//返回当前时间的小时date.getMinutes();//返回当前时间的分钟date.getSeconds();//返回当前时间的秒数date.getMilliseconds();//返回当前时间的毫秒数 日期转换： 基本包装类型 三个特殊的引用类型：String/Number/Boolean 例： var s1 = &quot;zhangsan&quot;; var s2 = s1.substring(5); s1是基本类型，基本类型是没有方法的 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象 相当于：123var s1 = new String(\"zhangsan\");var s2 = s1.substring(5);s1 = null; 注意：Number和Boolean基本不用，而且会引起歧义 创建基本包装类型的对象：1234var num = 18; //数值，基本类型var num = Number(\"18\"); //类型转换，基本类型var num = new Number(18); //基本包装类型，对象//**new会改变this的指向，并返回** String类型 String类型是字符串的包装类型，提供给我们很多操作字符串的方法var strObj = new String(&quot;hello world&quot;); 对象有方法和属性 属性：length返回当前字符串总共多少字符 方法：注意：字符串中所有的方法都不会改变字符串本身，操作完成后会返回一个新的字符串。 字符方法 charAt(); //获取指定位置处字符 charCodeAt(); //获取指定位置处字符的ASCII码 str[0]; //ES5，IE8+支持 和charAt()等效 操作方法 concat(); //拼接字符串，和+一样 slice(); //从start位置开始，截取到end位置，end取不到 substring(); //从start位置开始，截取到end位置，end取不到 substr(); //从start位置开始，截取length个字符 位置方法 indexOf(); //返回指定内容在元字符串中的位置。如果没有，则返回-1； lastIndexOf(); //从后往前找，只找第一个匹配的。没有则返回-1； 其他方法 trim()； //只能去除字符串前后的空白 split()； //把字符串切割成字符数组，参数是什么，就以什么来分割； 大小写转换方法 to(Locale)UpperCase(); //转换大写 to(Locale)LowerCase(); //转换小写 匹配方法 search(); replace();//从左往右找，找到一个替换后就返回 localeCompare(); //两个字符串比较的是ASCII码 s1.localeCompare(s2); s1 &gt; s2 返回正数，一般是1 s1 == s2 返回0 s1 &lt; s2 返回负数，一般是-1 fromCharCode() String.fromCharCode(101,102,103); //把ASCII码转换成字符串.","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"js高级","slug":"js高级","date":"2015-02-27T12:50:55.000Z","updated":"2017-02-28T12:49:40.092Z","comments":true,"path":"2015/02/27/js高级/","link":"","permalink":"http://yoursite.com/2015/02/27/js高级/","excerpt":"","text":"offset系列 offsetWidth和offsetHeight 用来得到对象的大小 offsetHeight和style.height的区别 demo.style.height只能获取 行内样式 ，如果样式写到了其他地方，甚至根本就没写，便无法获取 style.height是 字符串（而且带单位） ，offsetHeight是 数值 demo.style.height可以 设置 行内样式，offsetHeight是只读属性 因此，一般用demo.offsetHeight来获取某元素的真实宽度/高度，用style.height来设置宽度/高度 offsetHeight的构成 offsetHeight = height+padding+border； offsetWidth = width+padding+border; 即：包括 自身高度 内边距 边框，不包括 外边距 offsetParent 返回该对象距离最近的 带有定位 的父级 如果当前元素的所有父级元素都没有定位（position为absolute或relative），offsetParent为body 如果当前元素的父级元素中有定位（position为absolute或relative），offsetParent取最近的那个父级元素 另外注意offsetParent与parentNode的区别parentNode只找自己的上一级（亲爹） offsetLeft 和 offsetTop 用来得到对象的位置（注意：没有offsetRight和offsetBottom） offsetLeft的构成 到距离自身最近的（带有定位的）父元素的 左侧 的距离； 如果所有父级都没有定位则以body 为准； offsetLeft 是 自身 border 左侧到 父级 padding 左侧（即 父级 border 右侧）的距离； offsetLeft和 style.left 的区别 style.left只能获取行内样式 offsetLeft 只读 ，style.left可读可写 offsetLeft是 数值 ，style.left是 字符串 并且有单位px 如果没有加定位，style.left获取的数值可能是无效的 最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准 例如：left:20px; margin:20px; Math对象 Math对象常用方法 Math.ceil(x);//天花板函数，向上取整 Math.floor(x);//地板函数，向下取整 Math.round(x);//就近取整，会整体比较，以 .5 为界限，小于的舍，大于的入，等于的，正数入负数舍 Math.abs(x);//取绝对值例： Math.ceil(1.5);//2 Math.ceil(-1.5);//-1 Math.floor(1.5);//1 Math.floor(-1.5);//-2 Math.round(1.5);//2 Math.round(-1.5);//-1 Math.abs(-1.5);//1.5 动画原理 动画原理公式 动画原理公式： leader = leader + step; leader表示盒子当前位置 step表示步长 box.style.left = box.offsetLeft + 10 + &quot;px&quot;; 让setInterval不断执行某个函数修改盒子的位置属性最后就实现了动画的效果 动画函数封装 动画函数较为复杂，却又很常用对于这样的函数，我们一般都会进行封装 需求：能够让任意对象移动到指定位置。 动画函数改进 然而封装之后的函数还有很多问题，所以我们要对其进行进一步改进 判断运动方向 完善终点检测 终点清除定时器 手动设置对象位置到终点 调用开始先清理定时器，防止多次调用 12345678910111213141516//需求：让任意对象移动到指定位置 function animate(obj, target) &#123; clearInterval(obj.timer);//防止重复设定定时器 如果有就清掉 如果没有也无所谓 obj.timer = setInterval(function () &#123; var leader = obj.offsetLeft;//获取用offset var step = 10; step = leader &lt; target ? step : -step;//往左往右都行 if (Math.abs(leader - target) &gt;= Math.abs(step)) &#123;//距离大于步长就可以走 leader = leader + step; obj.style.left = leader + \"px\";//字符串而且有单位 &#125; else &#123; obj.style.left = target + \"px\";//手动放到目标上 clearInterval(obj.timer);//到达目标后清理定时器 &#125; &#125;, 15);//每秒 25帧就有动画效果了 60帧就比较细腻了 &#125; scroll系列 scrollHeight 和scrollWidth 对象内部实际内容的高度/宽度 scrollTop 和scrollLeft 被卷去部分的 顶部/左侧 到可视区域 顶部/左侧 的距离 页面滚动座标 获取页面滚动座标 页面滚动座标非常常用，但是有很大的兼容性问题，可以合写为： 123var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;//window.pageYOffset是主流的浏览器都支持的写法，后面的是专为类似IE6/7/8而准备的，如果获取不到，最后是0；var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; 封装自己的scroll() 由于非常常用，每次都写上面那一大堆很麻烦。我们可以封装一个自己的scroll()方法，返回页面滚动座标。 123456function scroll() &#123; return &#123; top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; &#125;&#125; 调用格式： scroll().top;//返回对象被卷去部分的 顶部 到可视区域 顶部 的距离 scroll().left//返回对象被卷去部分的 左侧 到可视区域 左侧 的距离 onscroll事件：每滚动一像素都会触发该事件 缓动动画 原理公式 动画公式leader = leader + step 匀速动画公式step = 定值 leader = leader + step 缓动动画公式step = ( target - leader ) / 10 leader = leader + step 缓动动画的好处 他的移动是有尽头的。不像基础匀速运动那样无限移动。 有非常逼真的缓动效果，实现的动画效果更细腻。 如果不清除定时器，物体永远跟着目标leader在移动。 缓动函数封装1234567891011121314//封装 动画函数 能让任意对象 移动到指定位置 function animate(obj, target) &#123; clearInterval(obj.timer);//清理定时器，避免重复调用定时器 obj.timer = setInterval(function () &#123; var leader = obj.offsetLeft; var step = (target - leader) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);//step要取整数，且数值上大于等于自己，所以正数向上取整，负数向下取整 leader = leader + step; obj.style.left = leader + \"px\"; if (leader === target) &#123; clearInterval(obj.timer); &#125;//当位置等于目标时，清除定时器 &#125;, 15); &#125; 封装缓动框架 封装 获取盒子计算后样式（即最终样式）的方法 123456789//封装 获取计算后样式属性的兼容函数 能够获取任意对象的任意属性 function getStyle(obj, attr) &#123; if (window.getComputedStyle) &#123;//主流的浏览器支持的方法，W3C规定的 return window.getComputedStyle(obj, null)[attr]; //第二个参数是伪元素，传入null即可 &#125; else &#123; return obj.currentStyle[attr];//非主流的IE6/7/8采用的方法 &#125; &#125; 访问属性的两种方式 div.style.width div.style[&quot;width&quot;] 封装123456789101112131415161718192021222324252627282930313233343536373839function animate(obj, json, fn) &#123;//json &#123;attr:target&#125; clearInterval(obj.timer); obj.timer = setInterval(function () &#123; //定时器肯定要清除 每一个属性都到达了才能清除 //假设这一次执行完成后 所有属性都到达了目标值 var flag = true; for (var k in json) &#123;//json 属性名:属性值 attr:target k:json[k] if (k === \"opacity\") &#123;//单独处理透明度 //var leader = parseInt(getStyle(obj, k)) || 0; var leader = getStyle(obj, k) * 100;//透明度没有单位的 也不用parseInt //没必要给默认值 也不应该给 var target = json[k] * 100; var step = (target - leader) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); leader = leader + step; obj.style[k] = leader / 100; //之前扩大100倍 现在缩小100倍数 透明度没有单位 &#125; else if (k === \"zIndex\") &#123;//层级也要特殊处理 obj.style.zIndex = json[k];//层级不需要渐变 直接设置成目标值 &#125; else &#123; var leader = parseInt(getStyle(obj, k)) || 0; var target = json[k]; var step = (target - leader) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); leader = leader + step; obj.style[k] = leader + \"px\"; &#125; if (leader !== target) &#123;//当前属性还没有到达目标 flag = false;//说明假设错了 &#125; &#125; if (flag) &#123;//最后仍然是true 说明都到了 clearInterval(obj.timer);//清理定时器 if (fn) &#123;//如果有才调用 fn();//动画执行完成后 会执行传入的回调函数 &#125; &#125; &#125;, 15); &#125; client系列 clientWidth和clientHeight 偏移offsetWidth: width + padding + border 卷曲scrollWidth: width + padding //不包含border 指的是内部内容的大小 可视clientWidth: width + padding //不包含border clientTop和clientLeft clientTop和clientLeft没什么用 他们就是borderTop和borderLeft（如果有滚动条会包含滚动条的宽度，但谁见过滚动条在顶部或者左侧的？！） 网页可视区宽和高 网页可视区宽高的兼容写法 页面可视区宽高非常常用，但是有很大的兼容性问题，可以合写为 1var clientWidth = window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth|| 0; 封装自己的client() 1234567//封装一个 能够获取网页可视区宽高的兼容函数function client() &#123; return &#123; width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0, height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0 &#125;;&#125; 体会响应式布局的原理 当页面宽度 大于 960 像素的时候 页面为红色并显示computer 当页面宽度 大于 640 小于 960 页面为绿色并显示tablet 剩下的情况为黄色并显示mobile 123456789101112131415161718192021222324252627282930var timer = null;responsive();//onscroll onresize onmousemove事件 执行频率很快//如果要执行的是非常消耗资源的代码 并且没必要频率那么大 可以进行节流window.onresize = function () &#123; clearTimeout(timer); timer = setTimeout(responsive, 500);&#125;;function responsive() &#123; console.log(\"很消耗资源\"); if (client().width &gt; 960) &#123;//电脑 document.body.style.backgroundColor = \"red\"; document.body.innerHTML = \"computer\"; &#125; else if (client().width &gt; 640) &#123;//平板 document.body.style.backgroundColor = \"green\"; document.body.innerHTML = \"tablet\"; &#125; else &#123; document.body.style.backgroundColor = \"yellow\"; document.body.innerHTML = \"moblie\"; &#125;&#125;//封装一个 能够获取网页可视区宽高的兼容函数function client() &#123; return &#123; width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0, height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0 &#125;;&#125; 事件对象 事件 oncnlick、onmouseover、onmouseout、onfocus、onblur 事件对象简介 在触发事件时，会产生一个事件对象 event，这个对象中包含着与事件有关的信息。 所有浏览器都支持event对象，但支持的方式不同。比如鼠标操作时候，会添加鼠标位置的相关信息到事件对象中。 普通浏览器支持 传入参数 IE6、7、8 支持 window.event。 事件对象的兼容性写法var event = event || window.event; 三个重要坐标 clientX clientY 当前窗口的左上角为基准点 screenX screenY 当前屏幕的左上角为基准点 pageX pageY 以当前文档（即网页）的左上角为基准点 IE678不支持pageX和pageY 但是我们可以采取另一种方式 12var pageY = event.pageY || event.clientY + document.documentElement.scrollTop;var pageX = event.pageX || event.clientX + document.documentElement.scrollLeft; 事件目标 12//兼容IE浏览器的写法var targetId = event.target ? event.target.id : event.srcElement.id; 注册事件的三种方式 传统on方式（onclick） 对同一个事件目标设置两次以上的同样事件，后面的事件会覆盖前面的时间 addEventListener(主流浏览器都支持) 可以给同一个对象的同一个事件注册多个事件处理函数（监听者）,后面不会覆盖前面。 可以设定捕获或者冒泡。 attachEvent(IE6、7、8) 可以给同一个对象的同一个事件注册多个事件处理函数（监听者）,后面不会覆盖前面。 可以设定捕获或者冒泡。 1234567891011//封装 注册事件 的兼容函数//1.元素对象 2.事件的名称（传入没有on的字符串） 3.事件处理函数 function addEvent(element, eventName, listener) &#123; if(element.addEventListener) &#123; element.addEventListener(eventName, listener, false); &#125; else if(element.attachEvent) &#123; element.attachEvent(\"on\" + eventName, listener); &#125; else &#123; element[\"on\" + eventName] = listener; &#125; &#125; 123456789//调用封装的addEvent函数//例如：为btn添加点击事件btn.onclick = function() &#123; alert(\"呵呵哒\");&#125;;//调用函数来实现addEvent(btn, \"click\", function() &#123; alert(\"呵呵哒\");&#125;); 移除事件的三种方式 on方式 btn.onclick = null; removeEventListener 如果注册的时候使用的是匿名函数，则无法移除 detachEvent 如果注册的时候使用的是匿名函数，则无法移除 1234567891011//封装 移除事件的兼容方法//function removeEvent(element, eventName, listener) &#123; if(element.removeEventListener) &#123; element.removeEventListener(eventName, listener, false); &#125; else if(element.detachEvent) &#123; element.detachEvent(\"on\" + eventName, listener); &#125; else &#123; element[\"on\" + eventName] = null; &#125;&#125; 1234567//调用removeEvent函数//function fn () &#123; alert(\"呵呵哒\");&#125;//调用removeEvent(btn, \"click\", fn); 注意：通过innerHTML清空内容的时候和事件相关的函数不会被销毁，仍然遗留在内存中，因此建议使用removeChild来清除 事件捕获 btn.addEventListener(“click”,handle,true); 最后一个参数为true-事件捕获 事件冒泡 当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。 btn.addEventListener(element,”click”,false); 最后一个参数为false-事件冒泡 大多数浏览器都支持-推荐使用的方式 123&lt;div id=\"father\"&gt; &lt;div id=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; son--&gt;father--&gt;document.body--&gt;document.documentElement(html)--&gt;document--&gt;window 事件传播的三个阶段是： 捕获阶段 冒泡阶段 目标阶段事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。 注意：不是所有的事件都能冒泡。以下事件不冒泡：blur、focus、load、unload。 阻止事件冒泡 123456//兼容IE浏览器的方法 if(event.stopPropagation)&#123; event.stopPropagation();&#125; else &#123; event.cancelBubble = true;&#125; 鼠标事件 mousedown mouseup mousemove mouseover mouseout click dblclick 键盘事件 onkeydown onkeypress onkeyup 事件对象的属性： onkeydown onkeyup 输出的是键盘码 onkeypress输出的是ASCII码表 键盘码中只有数字字母与ASCII码编号相同 正则表达式 声明和使用 通过构造函数定义 var 变量名= new RegExp(/表达式/); 通过直接量定义（简单方便，我们一般用这个） var 变量名= /表达式/; 常用方法，可用于检测传入的字符串是否符合该规则并返回布尔值 exp.test(“要检测的字符串”) 预定义类和转义符 预定义类 . [^\\n\\r] 除了换行和回车之外的任意字符 \\d [0-9] 数字字符digit \\D [^0-9] 非数字字符 \\w [a-zA-Z0-9] 单词字符(所有的英文字母数字和) word \\W [^a-zA-Z0-9_] 非单词字符 \\s [\\f\\r\\n\\t\\v] 不可见字符 space \\S [^\\f\\r\\n\\t\\v] 可见字符 转义符 \\f 表示换页 form feed \\t 表示水平制表符 table \\v 表示垂直制表符 vertical table| 表示或 或的优先级最低 可以通过()提升优先级 字符类简单类[abc] 表示该位置可以出现的字符 负向类[^abc] 表示该位置不可以出现的字符 范围类[a-e] 表示该位置可以出现的字符的范围 组合类[a-xA-E0-9] 范围类的组合 边界 量词 括号 边界^ 会匹配行或者字符串的起始位置 ^只有在[]内才表示非 在外边表示开始 \\$ 会匹配行或字符串的结尾位置 ^\\$在一起 表示必须是这个（精确匹配） 量词&quot;*&quot; 重复零次或更多 x&gt;=0 &quot;+&quot; 重复一次或更多次 x&gt;=1 &quot;?&quot; 重复零次或一次 x=(0||1) {n} n次 x=n {n,} 重复n次或更多 x&gt;=n {n,m} 重复出现的次数比n多但比m少 n&lt;=x&lt;=m 括号总结()表示一组 []表示一个字符的位置 {}表示次数 常见项目的匹配 常见项目的匹配网上有很多（例如搜索常用正则表达式大全），无需记忆，能看懂即可匹配国内电话号码： `&lt;pre style=&quot;background:#272822&quot;&gt;/^0\\d{2,3}-\\d{7,8}$/&lt;/pre&gt;` 匹配姓名： `&lt;pre style=&quot;background:#272822&quot;&gt;/^[\\u4e00-\\u9fa5]{2,}$/&lt;/pre&gt;` 匹配腾讯QQ号： `&lt;pre style=&quot;background:#272822&quot;&gt;/^[1-9]\\d{4,10}$/&lt;/pre&gt;` 匹配手机号： `&lt;pre style=&quot;background:#272822&quot;&gt;/^(13[0-9]|14[57]|15[0-9]|18[0-9])\\d{8}$/&lt;/pre&gt;` 匹配邮箱： `&lt;pre style=&quot;background:#272822&quot;&gt;/^\\w+([+-.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/&lt;/pre&gt;` 封装自己的trim方法 replace() 方法 格式: 字符串对象.replace(正则式或字符串，替换的目标字符) 返回值: 替换后的新字符串 封装自己的trim()方法 1234567//使用trim()方法检测用户输入function trim(str) &#123; return str.replace(/^\\s+/,\"\").replace(/\\s+$/,\"\");&#125;function trim(str) &#123; return str.replace(/^\\s+|\\s+$/g,\"\");&#125;","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"无缝轮播图","slug":"无缝轮播图","date":"2015-02-25T12:30:15.000Z","updated":"2017-02-28T12:58:27.429Z","comments":true,"path":"2015/02/25/无缝轮播图/","link":"","permalink":"http://yoursite.com/2015/02/25/无缝轮播图/","excerpt":"","text":"无缝轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative; &#125; .screen &#123; width: 500px; height: 200px; /*overflow: hidden;*/ position: relative; &#125; .screen li &#123; width: 500px; height: 200px; overflow: hidden; float: left; &#125; .screen ul &#123; position: absolute; left: 0; top: 0px; width: 3000px; &#125; .all ol &#123; position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center; &#125; .all ol li &#123; float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer; &#125; .all ol li.current &#123; background: yellow; &#125; #arr &#123; display: none; &#125; #arr span &#123; width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: '黑体'; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff; &#125; #arr #right &#123; right: 5px; left: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"all\" id='box'&gt; &lt;div class=\"screen\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/5.jpg\" width=\"500\" height=\"200\"/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt;&lt;/ol&gt; &lt;/div&gt; &lt;div id=\"arr\"&gt;&lt;span id=\"left\"&gt;&amp;lt;&lt;/span&gt;&lt;span id=\"right\"&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var timer = null; //0.找人 var box = document.getElementById(\"box\"); var screen = box.children[0]; var ul = screen.children[0]; var ol = screen.children[1]; var ulLis = ul.children;//所有的广告 //箭头 var arr = document.getElementById(\"arr\"); var left = document.getElementById(\"left\"); var right = document.getElementById(\"right\"); var imgWidth = screen.offsetWidth; //alert(imgWidth) //1.动态生成结构 //1.1根据广告的数量 动态生成按钮 for (var i = 0; i &lt; ulLis.length; i++) &#123; var li = document.createElement(\"li\");//循环一次就创建一个li li.innerHTML = i + 1; ol.appendChild(li);//放到ol中 &#125; //1.2给最开始的按钮先加一个高亮 var olLis = ol.children;//所有按钮 olLis[0].className = \"current\"; //1.3克隆第一张图片 放到最后 var firstImg = ulLis[0].cloneNode(true);//克隆出来的 假的第一张 ul.appendChild(firstImg); //2.鼠标经过按钮 //2.1给所有的按钮 注册鼠标经过事件 鼠标经过当前按钮 当前按钮排他 for (var j = 0; j &lt; olLis.length; j++) &#123; olLis[j].index = j;//用一个自定义属性 保存索引 olLis[j].onmouseover = function () &#123;//给每一个按钮注册鼠标经过事件 //干掉所有人 for (var k = 0; k &lt; olLis.length; k++) &#123; olLis[k].className = \"\"; &#125; //留下我自己 this.className = \"current\"; //除了要让当前按钮亮起 还要把ul移动到指定位置 //目标 和 当前按钮的索引有关 和 图片宽度有关 而且是负数 var target = -this.index * imgWidth; animate(ul, target); //*********鼠标经过按钮的时候 // 记录当前显示的图片的索引的pic 以及记录当前亮起的按钮的索引的square 要统一 //统一成当前按钮的索引 //pic = this.index; //square = this.index; pic = square = this.index; &#125;; &#125; //3.鼠标点击箭头 //3.1鼠标经过盒子显示箭头 box.onmouseover = function () &#123; arr.style.display = \"block\"; clearInterval(timer);//停止自动滚动 &#125;; //鼠标离开盒子隐藏箭头 box.onmouseout = function () &#123; arr.style.display = \"none\"; //鼠标离开后还要继续滚 timer = setInterval(right.onclick, 1000); &#125;; var pic = 0;//记录当前显示的图片的索引 var square = 0;//记录当前应该亮起的按钮 //3.2点击右箭头 right.onclick = function () &#123; //如果是最后一张图 需要把ul瞬间放到开始的位置 然后做从真的第一张到第二张的动画 if (pic === ulLis.length - 1) &#123; ul.style.left = 0 + \"px\";//瞬间放到开头 pic = 0;//把索引也归零 &#125; pic++;//计算出下一张 //目标 和pic有关 和 图片宽度有关 而且是负数 var target = -pic * imgWidth; animate(ul, target); //4.按钮也得跟着 //按钮的索引不能一直加 要判断一下 if (square &lt; olLis.length - 1) &#123;//小于最后一个按钮的索引 square++; &#125; else &#123; square = 0; &#125; //排他 //干掉所有人 for (var i = 0; i &lt; olLis.length; i++) &#123; olLis[i].className = \"\"; &#125; //留下对应的 olLis[square].className = \"current\"; &#125;; //3.3点击左箭头 left.onclick = function () &#123; //如果是第一张图 需要把ul瞬间放到最后的位置 然后做从假的第一张到真的最后一张 if (pic === 0) &#123; ul.style.left = -(ulLis.length - 1) * imgWidth + \"px\";//瞬间放到最后 pic = ulLis.length - 1;//把索引也变为最后的 &#125; pic--;//计算出下一张 //目标 和pic有关 和 图片宽度有关 而且是负数 var target = -pic * imgWidth; animate(ul, target); //4.按钮也得跟着 //按钮的索引不能一直减小 要判断一下 if (square &gt; 0) &#123;//大于第一个按钮的索引 square--; &#125; else &#123; square = olLis.length - 1;//等于最后一个按钮的索引 &#125; //排他 //干掉所有人 for (var i = 0; i &lt; olLis.length; i++) &#123; olLis[i].className = \"\"; &#125; //留下对应的 olLis[square].className = \"current\"; &#125;; timer = setInterval(right.onclick, 1000);//自动滚动 function animate(obj, target) &#123; clearInterval(obj.timer); obj.timer = setInterval(function () &#123; var leader = obj.offsetLeft; var step = 30; step = leader &lt; target ? step : -step;//往左往右都行 if (Math.abs(leader - target) &gt;= Math.abs(step)) &#123;//距离大于步长就可以走 leader = leader + step; obj.style.left = leader + \"px\"; &#125; else &#123; obj.style.left = target + \"px\";//手动放到目标上 clearInterval(obj.timer); &#125; &#125;, 15); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]},{"title":"DOM笔记","slug":"DOM笔记","date":"2015-02-21T08:23:49.000Z","updated":"2017-02-28T12:34:31.502Z","comments":true,"path":"2015/02/21/DOM笔记/","link":"","permalink":"http://yoursite.com/2015/02/21/DOM笔记/","excerpt":"","text":"DOM笔记内容概念 文档(Document)：就是指HTML或者XML文件； 节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有： 元素节点 属性节点 文本节点 注释节点 元素(Element)：HTML文档中的标签可以称为元素 获取元素getElementById();//通过id获取元素(只能被document调用) getElementsByTagName();//通过标签名获取元素，返回一个由元素对象组成的伪数组(既可以被document调用，又可以被元素对象调用，被元素对象调用时表示在该元素对象内部执行查找) getElementsByClassName();//通过类名获取元素，返回一个由元素对象组成的伪数组。IE6、7、8有兼容问题(既可以被document调用，又可以被元素对象调用，被元素对象调用时表示在该元素对象内部执行查找) 123456789101112131415161718192021222324//封装 通过类名获取元素 的兼容函数function getElementsByClassName(element,className) &#123; if(element.getElementsByClassName) &#123;//如果支持，直接返回 return element.getElementsByClassName(className); &#125; else &#123; //寻找指定元素内部所有的标签 一个一个标签去判断 //如果符合要求 就放到一个数组里 最后返回这个数组 var filterArr = []; var elements = element.getElementsByTagName(\"*\"); //把每个标签取出来一个一个判断类名是否符合要求 for(var i = 0; i &lt; elements.length; i++) &#123; var nameArr = elements[i].className.split(\" \"); //遍历类名数组 看看有没有和className相等的类名 for(var j = 0; j &lt; nameArr.length; j++) &#123; //nameArr[j]//每一个类名 if(nameArr[j] === className) &#123;//当前元素是我要的 filterArr.push(elements[i]);//把当前元素放入数组 break;//跳出对当前元素的类名的数组的循环 &#125; &#125; &#125; return filterArr; &#125;&#125; 设置属性元素对象.属性名 = &quot;属性值&quot;; 等价于： &lt;标签 属性名=&quot;属性值&quot;&gt; 绑定事件事件三要素: 事件源.事件 = function () { 事件处理程序 }; 等价于: &lt;标签 事件 = &quot;事件处理程序&quot;&gt; 内部文本属性 innerHTML; //获取和设置标签中的内容。 设置的时候，如果如果是符合标签规则的文本 会设置成标签。即设置的内容会当作节点对象被解析到DOM树上。 调用方式：element.innerHTML = &quot;content&quot;; box.innerHTML = &quot;&lt;li&gt;1&lt;/li&gt;&quot;;//直接当做li标签，页面上只显示 ·1 innerText //获取和设置标签中的内容，设置的内容不管是否是符合标签规则的文本，都会被当作普通文本。有兼容问题，用textContent代替 调用方式：element.innerText = &quot;content&quot; box.innerText = &quot;&lt;li&gt;1&lt;/li&gt;&quot;;//页面上输出&lt;li&gt;1&lt;/li&gt; 通过能力检测封装一个自己的设置内部文本的方法12345678//设置内部文本兼容性函数function setInnerText(element,content) &#123; if(typeof element.innerText === \"String\") &#123; element.innerText = content; &#125; else &#123; element.textContent = content; &#125;&#125; 12345678//获取内部文本的兼容性函数function getInnerText(element) &#123; if(typeof element.innerText === \"String\") &#123; return element.innerText; &#125; else &#123; return element.textContent; &#125;&#125; 常用表单属性 常见的表单元素属性有： type、value、checked、selected、disabled type：可以设置input元素的类型 value：可以设置input元素的值 checked：可以设置input元素是否选中 selected：可以设置下拉列表select中的option是否被选中 disabled：可以设置input元素是否被禁用 文本框获取焦点和失去焦点 获取焦点 事件是onfocus 失去焦点 事件是onblur (不是所有的标签都有这个事件) 自定义属性 w3c规定的属性 标签和对象会相互影响 没规定的各自是各自的 标签中有规定的属性 会反映到对象上 标签中没有规定的属性 不会反映到对象上 标签中有规定的属性 在对象身上修改 会影响标签 标签中没有规定的属性 在对象身上修改 不会影响标签 getAttribute();//设置标签属性 setAttribute();//获取标签属性 removeAttribute();//移除标签属性 节点(node) 节点类型 node.nodeType;//返回数字 1：表示元素节点； 2：表示属性节点； 3：表示文本节点； 8：表示注释节点； 节点名称 node.nodeName;//节点名称（标签名） 节点值 node.nodeValue;//元素节点的nodeValue始终是null 节点层次 所有获取节点相关属性都没有兼容性问题 childNodes //子节点 children //子元素 所有浏览器都支持 nextSibling //下一个兄弟节点 nextElementSibling //下一个兄弟元素 有兼容性问题 previousSibling//上一个兄弟节点 previousElementSibling //上一个兄弟元素 有兼容性问题 firstChild //第一个节点 firstElementChild //第一个子元素 有兼容性问题 lastChild //最后一个子节点 lastElementChild //最后一个子元素 有兼容性问题 parentNode //父节点 （一定是元素节点，所以无需处理） 封装函数来解决兼容性问题123456789101112131415//获取下一个兄弟元素function getNextElementSibling(element) &#123; //能力检测 if(element.nextElementSibling) &#123; return element.nextElementSibling;//如果有，直接返回 &#125; else &#123; //下一个兄弟节点 这是所有浏览器都支持的 var next = element.nextSibling; //循环条件：有下一个子节点 并且类型不是想要的 while(next &amp;&amp; next.nodeType !== 1) &#123; next = next.nextSibling; &#125; return next; &#125;&#125; 123456789101112131415//获取上一个兄弟元素function getPreviousElementSibling(element) &#123; //能力检测 if(element.previousElementSibling) &#123; return element.previousElementSibling;//如果有，直接返回 &#125; else &#123; //上一个兄弟节点 这是所有浏览器都支持的 var node = element.previousSibling; //循环条件：有上一个子节点 并且类型不是想要的 while(node &amp;&amp; node.nodeType !== 1) &#123; node = node.previousSibling; &#125; return node; &#125;&#125; 123456789101112//获取节点的第一个子元素function getFirstElement(element) &#123; if(element.firstElementChild) &#123; return element.firstElementChild; &#125; else &#123; var node = element.firstChild; while(node &amp;&amp; 1 != node.nodeType) &#123; node = node.nextSibling; &#125; return node; &#125;&#125; 123456789101112//获取节点的最后一个子元素function getLastElement(element) &#123; if(element.lastElementChild) &#123; return element.lastElementChild; &#125; else &#123; var node = element.lastChild; while(node &amp;&amp; 1 != node.nodeType) &#123; node = node.previousSibling; &#125; return node; &#125;&#125; 事件类型 onmouseover:鼠标经过 onmouseout:鼠标离开 onclick:点击 onkeyup:键盘弹起 onkeydown:键盘按下 onfocus:文本框获取焦点 onblur:文本框失去焦点 调用方式：btn.onclick = function() { 事件处理程序 }; 样式属性 style属性是对象，style对象的属性是字符串 style只能获取和设置行内样式 DOM对象中style的属性和标签中style内的值几乎一样 只是带有 - 的属性名较为特殊（如background-color变成了backgroundColor），因为在JS中 - 不能作为标识符 设置和获取样式 通过对象的style属性只能设置和获取行内样式 获取样式的时候 如果行内没有该样式 输出空字符串 设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要记得加单位 style对象 对应的是行内样式 获取样式 只能获取行内样式 获取到的是字符串 只有属性值 会带有单位 设置样式 设置的是行内样式(注意路径问题) 设置的也是字符串 一定要记得加单位 只设置值即可 常用属性 backgroundColor backgroundImage color width height border opacity (IE8以前filter: alpha(opacity=xx))//透明度 position left top right bottom z-index//层级（设置层级时，一定要先设置定位） display//元素隐藏后，不占位置，页面上的元素会重新排列 取值：none/block visibility//元素隐藏后，占位置 取值：hidden/visible 什么情况通过class 控制样式？什么情况通过style 控制样式？ 不严格的说： 如果样式很多，通过 直接控制类名 的方式加样式 如果样式比较少，通过直接设置比较方便 严格来说： 从标准的角度讲，即使是样式比较少的时候，设置样式也要用类名 但是有一类情况，是无论如何也必须直接通过JS加的–那就是涉及到计算的时候 动态创建元素 插入和移除节点 克隆节点 克隆的节点.cloneNode(布尔值);//参数为布尔值，false表示浅度克隆，即只克隆当前节点；true表示深度克隆，即把此节点的所有子节点一起克隆 在父元素中的最后追加子元素 father.appendChild(要追加的节点对象);//如果要追加的节点对象是已经存在的，则将该已存在的节点对象从原位置删除，放到要追加的位置；如果要追加的节点对象是克隆出来的，则原节点对象在原位置不变，只把克隆出来的节点对象放到要追加的位置。 在父元素中的某个子元素前面插入子元素 father.insertBefore(要插入的节点对象,插到这个节点对象的前面);//如果要追加的节点对象是已经存在的，则将该已存在的节点对象从原位置删除，放到要追加的位置；如果要追加的节点对象是克隆出来的，则原节点对象在原位置不变，只把克隆出来的节点对象放到要追加的位置。 从父元素中移除子元素 father.removeChild(要移除的子节点对象); 清空父元素 father.innerHTML=&quot;&quot;;//在清空内容的时候和事件相关的函数不会被销毁，任然遗留在内存中 因此如果方便的话，建议使用father.removeChild(son)来清除 动态创建结构 方式一：直接在文档中书写 document.write(&quot;内容&quot;);//如果页面已经加载好了 会把所有内容都干掉。write方法无法限定范围，只能被document调用. 方式二：改变元素对象内部的HTML innerHTML = &quot;内容&quot;;//可以限定范围。如果页面已经加载好了，会把所有内容都干掉。 调用方式：element.innerHTML = &quot;content&quot;; innerText//可以限定范围,有兼容问题，用textContent代替(兼容函数见第58行) 调用方式：element.innerText = &quot;content&quot; 方式三：创建或克隆节点并追加 createElement(tagName); cloneNode(); 然后appendChild()将节点追加到后面或者insertBefore()将节点插入到指定位置 通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行!","categories":[],"tags":[{"name":"JavaScript学习笔记","slug":"JavaScript学习笔记","permalink":"http://yoursite.com/tags/JavaScript学习笔记/"}]}]}